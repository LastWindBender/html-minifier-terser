import { ElementType } from 'htmlparser2';

import defaultOptions from './options/defaults.js';
import { voidTags } from './utils/tags';
import formatAttributes from './serializer/format-attributes.js';

class Serializer {
  constructor(options = defaultOptions) {
    this.options = options;
  }

  render(tree) {
    const nodes = Array.isArray(tree) ? tree : [tree];

    let output = '';

    for (let i = 0; i < nodes.length; i++) {
      output += this.renderNode(nodes[i]);
    }

    return output;
  }

  renderNode(node) {
    switch (node.type) {
      case ElementType.Root:
        return this.render(node.children);

      case ElementType.Tag:
      case ElementType.Script:
        return this.renderTag(node);

      case ElementType.Text:
        return this.renderText(node);

      case ElementType.Comment:
        return this.renderComment(node);

      case ElementType.Directive:
        return this.renderDirective(node);

      default:
        return '';
    }
  }

  renderTag(elem) {
    let openTag = `<${elem.name}`;

    const attrs = formatAttributes(elem, this.options);
    if (attrs) {
      openTag += ` ${attrs}`;
    }

    if (elem.children.length === 0 && this.options.keepClosingSlash) {
      openTag += '/>';
    } else {
      openTag += '>';
    }

    if (!this.options.includeAutoGeneratedTags && elem.startImplied) {
      openTag = '';
    }

    let children = '';
    if (openTag && elem.children) {
      children = this.render(elem.children);
    }

    let closeTag = !voidTags.has(elem.name) ? `</${elem.name}>` : '';
    if (!this.options.includeAutoGeneratedTags && elem.endImplied) {
      closeTag = '';
    }

    return openTag + children + closeTag;
  }

  renderText(elem) {
    return elem.data;
  }

  renderComment(elem) {
    return `<!--${elem.data}-->`;
  }

  renderDirective(elem) {
    return `<${elem.data}>`;
  }
}

export default Serializer;
